[[intro-reactive]]
= Введение в Реактивное программирование
Reactor is an implementation of the Reactive Programming paradigm, which can be summed up
as:

[quote, https://ru.wikipedia.org/wiki/Реактивное_программирование]
Реактивное программирование — парадигма программирования, ориентированная на потоки данных и распространение изменений. Это означает, что должна существовать возможность легко выражать статические и динамические потоки данных, а также то, что нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных.

As a first step in the direction of reactive programming, Microsoft created the Reactive
Extensions (Rx) library in the .NET ecosystem. Then RxJava implemented reactive
programming on the JVM.  As time went on, a standardization for Java emerged through the
*Reactive Streams* effort, a specification that defines a set of interfaces and
interaction rules for reactive libraries on the JVM. Its interfaces have been
integrated into Java 9 under the parent `Flow` class.

Парадигма реактивного программирования в обьектно ориентированных языках часто представляется как расширение
паттерная Observer. Так же можно сравнить реактивные потоки (stream) с хорошо всем знакомым паттерном Iterator.
Связка `Iterable`-`Iterator` есть во всех библиотеках. Основное отличие в том что  Iterator основан на  *pull*-модели,
а реактивные потоки использую *push*-подход.

Iterator - шаблон имеративного программирования. Ответственность за метод доступа к значениям лежит исключительно на `Iterable`.
Разработчик сам выбирает когда получить доступ к элементу последовательности вызвав метод `next()`.
В реактивных потоках, эквивалент вышеупомянутой связки `Publisher-Subscriber`.
Разница в том, что  `Publisher` уведомляет `Subscriber` о новых доступных значениях _по мере их поступления_,
и это уведомление(push) является сигналом к действиям.Кроме того, операции, применяемые к опубликованным значениям,
описываются в декларативном стиле, а не императивно: программист описывает логику вычислений,
а не описывает набор инструкций для последовательного выполнения.


В дополнение к push модели, кроме публикации значений, реактиное программирование четко описывает способы обработы ошибок
и завершения потоков.`Publisher` может выдвигать новые значения в его `Subscriber` (вызывая метод `onNext`),
может сигнализировать об ошибке (вызывая метод `onError`) или завершении (вызывая метод `onComplete`).
И ошибки и сигнал завершения  завершают последовательность. Это можно представить как:

[source]
onNext x 0..N [onError | onComplete]

Такой подход очень гибкий. Шаблон описывает случаи использования где нет значений,
есть одно значение или есть n значений (включая бесконечную последовательность значений, к примеру тики часов).

Но вначале давайте рассмотрим зачем нам вообще нужна такая асинхронная реактивная библиотека?

== Блокировки могут быть расточительны
Современные приложения могут обслуживатель большое количество пользователей одновременно,
и несмотря на то что аппаратное обеспечение, продолжает улучшаться, производительность современного
ПО по прежнему являвется ключевой проблемой.

Существует два основных способа увеличения производительности программы:

. *распаралелить*: использовать больше потоков и больше аппаратных ресурсов.
. *стремится к большей эффективности* в использовании имебщихся аппаратных ресурсов.

Обычно Java разработчики пишут используя блокирующий код. Этот подход хорош, пока не возникнет узкое место
в производительности программы, после этого приходится запускать дополнительные потоки,
выполнябщие аналогичный блокируемый код. Но такой подход к масштабированию обычно быстро вызывает
проблемы конкуретного доступа.

Еще хуже,что это вызовет блокировку ненужных ресурсов. Обратите внимание, как тольпо программа предполагает
работу с задержкой (особенно операции ввода/вывода, такие как запросы к БД или сетевое взаимодействие),
ресурсы тратятся зря, потому что поток (или несколько потоков) простаивает без работы,
находясь в состоянии ожидания данных.

Поэтому подход к распаралеливанию не является серебрянной пулей. Конечно, он хорошо подходит чтобы использовать все
доступные аппаратные ресурсы, но он также приводит к их неэффективному использованию.

== Асинхронность спасет нас?
Второй подход (из упомянутых ранее), в повышении эффективности, может стать решением проблемы расточительного
использования ресурсов. Написав _асинхронный_, _неблокируемый_код_,
вы позволите исполнителю переключатся на другую активную задачу *спользуя те же основные ресурсы*,
а затем вернутся к текущей задаче, когда асинхронная обработка другой завершится.

Какие есть способы написани асинхронного кода под JVM? Java предоставляет две модели асинхронного программирования:

* *Callbacks*: Асинхронные методы не возвращают значение, но принимают дополнительный парамер
`callback`(лямбда выражение или аноанимный класс) котоый вызывается, когда результат готов.
Врем известным примером является `EventListener` из библиотеки  Swing.
* *Futures*: Асинхроанные методы возвращают обьет `Future<T>` *немедленно*. Асинхронный процесс вычисляет
занчение `T`, а обьект `Future` является обверткой, для доступа к нему. Значение доступно не сразу, и обьект Future
можно опрашивать, пока значение не станет доступным. Например при использовании `ExecutorService` запуск `Callable<T>`
возвращает `Future` обьекты.

Что не так с этими методами? Каждый из них имеет свои ограничения в большинстве вариантов использования.

Композиция Callback'ов очень трудное занятие, написание такого кода быстро приводит
к результату который трудно читать и поддерживать.(известный всем "Callback Hell").

Рассмотрим пример: показать прять избранных обьектов в пользовательском интерфейсе или показать рекомендации, если
у пользователя нет избранных обьектов.
Для этого используются три сервиса(один возвращает IDs избранных обьектов,
второй получает обьекты, а третий получает обьекты предложений):

.Пример  Callback Hell
[source,java]
----
userService.getFavorites(userId, new Callback<List<String>>() { //<1>
  public void onSuccess(List<String> list) { //<2>
    if (list.isEmpty()) { //<3>
      suggestionService.getSuggestions(new Callback<List<Favorite>>() {
        public void onSuccess(List<Favorite> list) { //<4>
          UiUtils.submitOnUiThread(() -> { //<5>
            list.stream()
                .limit(5)
                .forEach(uiList::show); //<6>
            });
        }

        public void onError(Throwable error) { //<7>
          UiUtils.errorPopup(error);
        }
      });
    } else {
      list.stream() //<8>
          .limit(5)
          .forEach(favId -> favoriteService.getDetails(favId, //<9>
            new Callback<Favorite>() {
              public void onSuccess(Favorite details) {
                UiUtils.submitOnUiThread(() -> uiList.show(details));
              }

              public void onError(Throwable error) {
                UiUtils.errorPopup(error);
              }
            }
          ));
    }
  }

  public void onError(Throwable error) {
    UiUtils.errorPopup(error);
  }
});
----
<1> У нас есть сервисы, доступ к которым основан на callback: a `Callback` интерфейс с методамми,
которые вызываются в случае успеха или ошибки
<2> Первый сервис вызывает callback со списком  ID избранных обьектов.
<3> Если список пусты, мы переходим к `suggestionService`.
<4> `suggestionService` возвращает `List<Favorite>` во второй callback.
<5> Так как мы работаем с пользовательским интерфесом, мы должны гарантированно запустить код в потоке интерфейса.
<6> Мы используем Java 8 `Stream` что бы ограничить результат 5 элементами, и  передаем их в пользовательский интерфейс.
<7> На каждом уровне мы одинаково обрабатываем ошибки: показыаем их во всплывающем окне.
<8> Вернемся к ID избаррных элементов. Если сервис вернул список id, нам нужно получить полные обьекты
из `favoriteService`. Так как мы хотим только 5 элементов, мы ограничим поток ID 5 элементами.
<9> Еще один callback. На этот раз мы получаем полные обьекты `Favorite`, которые мы отображаем в пользовательском
интерфейсе внутри потока пользовательского интерфейса.

Мы написали много кода, его трудно читать и в нем есть повторяющиеся части.
Рассмотрим аналогичный код с использованием Reactor:

.Пример кода с использованием Reactor, функционально аналогичный примеру выше
[source,java]
----
userService.getFavorites(userId) // <1>
           .flatMap(favoriteService::getDetails) // <2>
           .switchIfEmpty(suggestionService.getSuggestions()) // <3>
           .take(5) // <4>
           .publishOn(UiUtils.uiThreadScheduler()) // <5>
           .subscribe(uiList::show, UiUtils::errorPopup); // <6>
----
<1> Мы начинаем с получения потока  ID избранных.
<2> Мы _асинхронно преобразуем_ их в полные обьекты `Favorite` (`flatMap`).
Теперь у нас поток обьектов `Favorite`.
<3> В случае если поток обьектов `Favorite` пустой, мы переключаемся на запасной поток от
`suggestionService`.
<4> Нас интересует не более 5 элементов из полученного потока.
<5> В конце мы хотим обработать каждый элемент в потоке пользовательского интерфейса.
<6> Мы запускаем поток(flow, не thread), описывая что делать с окончательной формой данных
(показывать ее в UI) и что делать в случае ошибки (показывать всплывающее окно).

What if you want to ensure the favorite IDs are retrieved in less than 800ms or, if it
takes longer, get them from a cache? In the callback-based code, that is a complicated
task. In Reactor it becomes as easy as adding a `timeout` operator in the chain:

.Пример с поддержкой  timeout и fallback
[source,java]
----
userService.getFavorites(userId)
           .timeout(Duration.ofMillis(800)) // <1>
           .onErrorResume(cacheService.cachedFavoritesFor(userId)) // <2>
           .flatMap(favoriteService::getDetails) // <3>
           .switchIfEmpty(suggestionService.getSuggestions())
           .take(5)
           .publishOn(UiUtils.uiThreadScheduler())
           .subscribe(uiList::show, UiUtils::errorPopup);
----
<1> Если код выше ничего не выдал за 800ms, выдать ошибку.
<2> В случае ошибки, использовать резервный `cacheService`.
<3> Остальная часть цепочки аналогичная предыдущему примеру

Обьеты Future намного лучше чем обратные вызовы, но они по прежнему не очень хороши в композиции,
несмотря на улучшения в  классе `CompletableFuture` добавленные в Java 8.
Совместное управление несколькими обьектами Future возможно, но не легко на практике.
Так же у  `Future` есть другие проблемы: легко написать код, приводящий к блокировке, вызвав метод `get`,
они не поддерживают ленивые вычисления, множественные возвращаемые значения и продвинутую обработку ошибок.


Рассмотрим другой пример: Мы получаем список IDs по которым мы получаем имя и статистику,
затем обьединяем их попарно, причем все асинхронно.

.Пример с  `CompletableFuture` композицией
[source,java]
----
CompletableFuture<List<String>> ids = ifhIds(); // <1>

CompletableFuture<List<String>> result = ids.thenComposeAsync(l -> { // <2>
	Stream<CompletableFuture<String>> zip =
			l.stream().map(i -> { // <3>
				CompletableFuture<String> nameTask = ifhName(i); // <4>
				CompletableFuture<Integer> statTask = ifhStat(i); // <5>

				return nameTask.thenCombineAsync(statTask, (name, stat) -> "Name " + name + " has stats " + stat); // <6>
			});
	List<CompletableFuture<String>> combinationList = zip.collect(Collectors.toList()); // <7>
	CompletableFuture<String>[] combinationArray = combinationList.toArray(new CompletableFuture[combinationList.size()]);

	CompletableFuture<Void> allDone = CompletableFuture.allOf(combinationArray); // <8>
	return allDone.thenApply(v -> combinationList.stream()
			.map(CompletableFuture::join) // <9>
			.collect(Collectors.toList()));
});

List<String> results = result.join(); // <10>
assertThat(results).contains(
		"Name NameJoe has stats 103",
		"Name NameBart has stats 104",
		"Name NameHenry has stats 105",
		"Name NameNicole has stats 106",
		"Name NameABSLAJNFOAJNFOANFANSF has stats 121");
----
<1> мы начинаем с Future, которое дает нам список `id` для дальнейшей обработки.
<2> Мы хотим начать асинхронную обработку как только получим список.
<3> Для каждого элемента в списке:
<4> Асинхронно получить связанное имя.
<5> Асинхронно получить связанную задачу.
<6> Обьединить оба результата.
<7> Теперь у нас есть список обьектов Future которые представляют все скомбинированные задачи.
Чтобы выполнить эти задачи, нам нужне преобразовать список в массив.
<8> Передаем полученный массив в метод `CompletableFuture.allOf`, который возвращает результат когда все `Future` выполнятся.
<9> Поскольку `allOf` возвращает `CompletableFuture<Void>`, мы повторно обходим список
futures, собирая их результат через `join()` (который здесь не блокируется, поскольку `allOf` гарантирует что все futures уже выполнились).
<10> Как только асинхронный "конвейер" запущен,мы ждем его обработку и возвращаем результат на проверку.

Т.к.в Reactor больше композиционных операторов, этот процесс может быть упрощен:

.Пример с использованием Reactor, код эквивалентен примеру с Future
[source,java]
----
Flux<String> ids = ifhrIds(); // <1>

Flux<String> combinations =
		ids.flatMap(id -> { // <2>
			Mono<String> nameTask = ifhrName(id); // <3>
			Mono<Integer> statTask = ifhrStat(id); // <4>

			return nameTask.zipWith(statTask, // <5>
					(name, stat) -> "Name " + name + " has stats " + stat);
		});

Mono<List<String>> result = combinations.collectList(); // <6>

List<String> results = result.block(); // <7>
assertThat(results).containsExactly( // <8>
		"Name NameJoe has stats 103",
		"Name NameBart has stats 104",
		"Name NameHenry has stats 105",
		"Name NameNicole has stats 106",
		"Name NameABSLAJNFOAJNFOANFANSF has stats 121"
);
----
<1> На этот раз, с асинхронно публикуемой последовательности  `ids` (`Flux<String>`).
<2> Мы асинхронно обрабатываем каждый элемент последовательности  дважды(внутри функции `flatMap`.
<3> Получить связанное имя.
<4> Получить связанную статистику.
<5> Асинхронно объединить два значения.
<6> Обьединить значения в  `List` как они станут доступны.
<7> В реальном коде, мы будем продолжать работать с `Flux` асинхронно проводить операции над ним
или подписываться на него. Скорее всего, мы бы получили в качестве результата  `Mono`.
Т.к, мы находимся в тесте, мы вызываем блокирующий метод,ожидаем завершения обработки,
и возвращаем агрегированный список значений.
<8> Проверяем результат.

Задачи Callback и Future похожи.В реактивном программировании они решаются
парой `Publisher-Subscriber`.

== От императивного к реактивному программированию
Реактивные библиотеки, такие как Reactor, направлены на устранение недостатков
"классических" подходов асинхронного программирования на JVM, и приследуют еще несколько целей:

* *Композиционность* и *читаемость*
* Данные как  *поток(flow)* управляемый с помощью богатого набора *операторов*
* Ничего не происходит пока вы не *подпишитесь (subscribe*
* *Backpressure* или _способность потребителя сигнализировать производителю
что уроверь отправки данных слишком большой
* *High level* but *high value* abstraction that is _concurrency-agnostic_

=== Композицонность и удобочитаемость
Под композиционностью, мы имеем в виду способность управлять несколькими асинхронными задачами,
используя результаты предыдущих задач в качестве входных данных последующих
или выполнение нескольких задач в стиле  fork-join, а так же повторного использования задач в качестве
дискретных компонентов в высокоуровневых системах.

Способность координировать задачи тесно связана с удобочитаемостью и ремонтопригодностью кода.
С ростом числа уровней асинхронных процессов, читать и писать код становится все труднее.
Как мы успели заметить, модель обраьных вызовов проста, но один из ее основных недостатков в том
что в сложных процессах вам понадобится выполнять обратные вызовы из обратных вызовов, которые вложены
в обратные вызовы и так далее. Такой код известен как  *Callback Hell*. Как вы можете догадаться
(или знаете из опыта), к такому коду сложно вернутся, его сложно читать и модифицировать.

Reactor предлагает богатый набор вариантов композиции,при этом код отражает процесс абстрактно,
и весь код в целом держится на одном уровне абстрации (вложенность сведена к минимуму).

=== Аналогия сборочной линии (конвейер)
Вы можете представлять данные, обрабатываемые реактивным приложением, как об обьектах, движущихся по
конвейеру. Reactor является одновременно конвейерной лентой и рабочими станциями.
Сырые обьекты поступают из источника  (`Publisher`) и в итоге становится продуктом, готовым к отправке
потребителю (`Subscriber`).

Сырые обьекты могут быть преобразованы и проходить различные этапы обработки, или быть частью большой
сборочной линии, которая обьединяет промежуточные части вместе.
Если в одной точке наблюдается сбой или засорение (возможно упаковка продуктов занимает непропорционально
большое время), перегруженная рабочая станция может сигнализировать вверх, что бы ограничить поток сырья.

=== Операторы
В Reactor, операторы являются рабочими станцииями в метафоре конвейера.
Каждый оператор добавляет поведение к `Publisher` и обораичивает предыдущий шаг `Publisher` в новый экземпляр.
Таким образом вся цепочка связана, оригинальные обьекты берутся из первого `Publisher` и движутся вниз
по цепочке, трансформируясь каждым звеном. В конце,  `Subscriber` завершает процесс.
Помните что ничего не происодит пока   `Subscriber` не подпишется на `Publisher`, вскоре мы это увидим.

TIP: Понимание того, что операторы создают новые экземплеры, поможет вам избежать распространенной ошибки.
Смотрие <<faq.chain,item>> в FAQ.

Хотя в спецификации Reactive Streams операторы вообще не определены,
одно из важнейших достоинств реактивных библиотек (таких как Reactor) -- богатный набор операторов.
Они охватывают много аспектов, от простых преобразований и фильтрации, до сложной композиции и обработки ошибок.

[[reactive.subscribe]]
=== Ничего не случится до `subscribe()`
В Reactor'е, когда вы пишите `Publisher` цепочку, данные не начинают поступать по умолчанию.
Вместо этого, вы создаете абстрактное описание вашего асинхронного процесса
(это может помочь с переиспользованием и композицией).

В момент  *подписки(subscribing)*, вы привязываете `Publisher` к  `Subscriber`, который запускает движение данных
во всей цепочке. Это достигается внутренним одиночным  `request` сигналом от `Subscriber`, который распространяется вверх,
до самого `Publisher`.

[[reactive.backpressure]]
=== Backpressure(обратное давление)
Распространение восходящих сигналов так же используется для реализации противодавления (backpressure),
которое мы описывали в аналогии с конвейром как сигнал обратной связи, отправляемый вверх по линии,
когда рабочая станция обрабатывает обьекты медленнее, чем рабочая станция, находящаяся выше по цепопочке.

Реальный механизм, специфицирвоанный в  Reactive Streams, давольно близок к этой аналогии:
подписчик может работать в _неогранниченном_ режиме, что позволяет источнику публиковать данные с максимально возможной
скоростью, или он может использовать механизм `request` чтобы собщить, что он готов обработать не более чем `n` элементов.

Промежуточные операторы так же могут изенять `request` в пути.  Представьте оператор `buffer`,
который групирует элементы партиями по 10. Если подписчик запрашивает  1 buffer, то для источника допустимо
поставить 10 элементов. Некоторые операторы реализуют стратегии **предварительной выборки (prefetching)**,
что позволяет избежать повторных обращений `request(1)`, это выгдоно когда создание элементов до их запроса
не является дорогостоящей операцией.

Это преобращует  push модель в  **push-pull гибрид** где нисходящий поток может вытянуть n элементов
из восходящего потока если они доступны. Но если элементы не готовы, они будут опубликованы восходящим потоком,
когда станут доступны.

[[reactive.hotCold]]
=== Горячие против Холодных
В семействе реактивных библиотек, две основные категории реактивных последовтаельностей: *горячие(hot)* и *холодные(cold)*.
Их различие отражает как реактивный поток реагирует на подписчиков:

- *Холодные* последовательности начинаются заново для каждого `Subscriber`, в том числе в источнике данных.
Например если источник оборачивает  HTTP запрос, новый HTTP запрос делается для каждой новой подписки.
- *Горячие* последовательности не начинаются с нуля для каждого `Subscriber`.
Поздние подписчики получают сигналы, публикуемые после того как они подписались.
Обратите внимание, что некоторые горячие реактивные потоки могут кэшировать или воспроизводить историю публикаций
полностью или частично. С общей точки зрения, горячая последовтельность может даже генерироваться,
когда ни один подписчик не слушает (это исключение из правила "Ничего не случится до `subscribe()`").

Для получения дополнительной информаци о горфчих и холодных потоках в Reactor, смотрите
<<reactor.hotCold,this reactor-specific section>>.

//TODO talk about concurrency agnostic? elements of functional style?
